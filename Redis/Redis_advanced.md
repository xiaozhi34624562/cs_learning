## Redis
### 来自于极客时间 [Redis核心技术与实战](https://time.geekbang.org/column/intro/100056701?utm_source=u_nav_web&utm_medium=u_nav_web&utm_term=u_nav_web)
#### 访问框架（网络框架访问）
- 网络连接的处理`|- 网络请求的解析
- 数据存取的处理
#### 索引模块
- 哈希表作为key-value索引，因为键值数据都是保存在内存中，保存的是具体值的指针
- 一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。所以，我们常说，一个哈希表是由多个 哈希桶组成的，每个哈希桶中保存了键值对数据。
- 哈希表操作变慢了
  - 哈希表的冲突问题
    - 问题：哈希桶的个数通常少于key的数量
    - solution：同一个哈希桶中的数据用一个链表来保存，他们之间一次用指针连接，哈希冲突链
  - rehash带来的操作阻塞
    - 问题：当一个哈希桶中的数据过多的时候，开始进行rehash，Redis默认使用了两个全局哈希表：哈希表1和哈希表2；分三步走
      - 给哈希表2分配更大的空间，例如是当前哈希表1大小的两倍
      - 把哈希表1中的数据重新映射并拷贝到哈希表2中
      - 释放哈希表1的空间
    - solution：渐进式rehash。每处理一个请求时，从哈希表1中的第 一个索引位置开始，顺带着将这个索引位置上的所有entries拷⻉到哈希表2中;等处理下一个请求时，再顺 带拷⻉哈希表1中的下一个索引位置的entries
#### 操作模块
#### 存储模块
- redis数据类型和底层数据结构
  - String：简单动态字符串
  - List：双向链表，压缩列表
  - Hash：压缩列表，哈希表
  - Sorted Set：压缩列表，跳表
  - Set：整数数组，哈希表
- 压缩列表
  - 压缩列表在 表头有三个字段zlbytes、zltail和zllen，分别表示列表⻓度、列表尾的偏移量和列表中的entry个数;压缩列 表在表尾还有一个zlend，表示列表结束;
  - 在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的⻓度直接定位， 复杂度是O(1)。而查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是O(N)了
- 数据结构的时间复杂度
  - 哈希表 O(1)
  - 跳表 0(logN)
  - 双向链表 O(N)
  - 压缩列表 O(N)
  - 整数数组 O(N)
#### 高性能IO模型
- Redis的网络IO和键值对读写是由 一个线程来完成的，这也是Redis对外提供键值存储服务的主要流程
- 大部分的操作是在内存上完成的
- 采用了高效的数据结构：哈希表和跳表
- 多路复用机制
#### 宕机了，Redis如何避免数据丢失 
- AOF日志
  - 命令执行成功后才会记录接收到的命令的日志
    - 确保每一次记录的命令都是正确的
    - 不会阻塞当前的写操作
    - 潜在风险：执行完命令没来得及记日志就宕机了；AOF避免了对当前命令的阻塞，但是可能会给下一个操作带来阻塞，日志是在主线程中执行
    - 解决办法：控制命令执行完后AOF日志写回磁盘的时机
      |配置项|写会时机|优点| 缺点|
      |:-----:|:-----:|:-----:|:------:|
      |Always|同步写回|可靠性高，数据丢基本不丢失|每个命令都要落盘，性能影响较大|
      |Everysec|每秒写回|性能适中|宕机的时候丢失1秒内的数据|
      |No|操作系统控制的写回|性能好|宕机时丢失数据较多|
    - AOF文件太大带来的性能问题
      - 文件系统本身对文件大小有限制，无法保存过大的文件
      - 如果文件太大，之后再往里面追加命令记录的话，效率会变低
      - 如果宕机，AOF中记录的命令要一个个被重新执行，日志文件太大，整个恢复过程就会很缓慢
      - 解决办法：AOF重写机制
        - AOF重写机制在重写时，redis根据数据库的现状创建一个新的AOF文件，可以把日志文件变小，把多条命令变成一条命令。但是AOF重写后，要把操作日志写回磁盘，仍然是一个非常耗时的过程。
        - AOF重写与AOF日志由主线程写回不同，重写的过程是由后台线程bgrewriteaof来完成，可以避免阻塞主线程导致的数据库性能下降
        - 重写的过程：一个拷贝，两处日志
          - 一个拷贝：每次执行重写的时候，主线程fork出后台的bgrewriteaof子进程。此时，fork会把主线程的内存拷贝一份给bgrewriteaof进程，这里面包含了数据库最新的数据，再不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志
          - 两处日志：第一处日志是正在使用的AOF日志，新的操作会放在它的缓冲区；第二处日志是重写日志，新的操作也会放在缓存中，重写完成后，这些新操作也会写入新的AOF文件
- RDB快照(Radis DataBase)
  - 和AOF相比，RBDB记录的是某一时刻的数据，并不是操作，所以在做数据恢复时，我们可以把RDB文件读入内存，很快就可以完成恢复
  - 给那些数据做快照？为了保证数据的可靠性，它执行的是全量快照。有两种操作方法：save（在主线程中执行，会导致阻塞），bgsave（创建一个子线程，专门用于写入RDB文件）
  - 快照时数据可以修改吗？在快照期间进行写操作，是Redis借助操作系统提供的写时复制技术（copy-on-write）。主线程要修改数据，数据会被复制一份，生成该数据的副本，然后bgsave子进程会把这个副本数据写入RDB文件，在这个过程中，主线程仍然可以直接修改原来的数据
  - 多久？怎么样保存数据？频繁将数据写入磁盘回给磁盘带来压力，多个快照竞争有限的磁盘，会造成恶性循环，从主线程fork出bgsave子进程，fork的过程本身会阻塞主线程。Redis4.0采用混合使用AOF日志和内存快照，内存快照以一定的频率执行，在两次快照之间，使用AOF日志记录这期间的所有命令操作
- 总结
  - 数据不能丢失时，内存快照和AOF的混合使用是一个好选择
  - 如果允许分钟级别的数据丢失，可以只使用RDB
  - 如果只使用AOF，有限使用everysec的配置选项，这在可靠性和性能之间取了一个平衡
#### 数据同步：主从数据库如何实现数据一致
- Redis提供主从库模式，以保证数据副本一致。读操作：主库、从库都可以接受；写操作：首先到主库执行，然后主库将写操作同步给从库
  - 主从数据库进行的第一次同步
    - 选定的从数据库输入命令 replicaof 主数据库IP 主数据库端口，即可确定这从关系
    - 第一阶段：从库给主库发送`psync ? -1`命令，表示要进行数据同步，psync命令包含了主库的runID（Redis实例启动时都会自动生成一个随机ID，第一次复制还不知道，所以标记为？）和复制进度offset（第一次复制，设置为-1）两个参数。主库收到psync命令后，会用FULLRESYNC响应命令带上两个参数：主库runID和主库目前的复制进度offset，返回给从库，并记录下这两个参数
    - 第二阶段：主库将所有数据同步给从库，从库收到数据后，在本地完成数据加载，这个过程依赖于内存快照生成的RDB文件。主库将数据同步给从库的时候，主库不会被阻塞，仍然可以正常接受请求，这期间的写记录没有记录在刚刚生成的RDB文件中，为了保证主从数据库的数据一致性，主库会在内存中用专门的replication buffer，记录RDB文件生成后的所有操作
    - 第三阶段：主库会把第二阶段执行过程中新收到的写命令发送给从库。具体的操作是， 当主库完成RDB文件发送后，就会把此时replication buffer中的修改操作发给从库，从库再重新执行这些操作。
    - 可以采取"主-从-从"的级联模式，来缓解主库的压力
- 主从库完成了全亮复制，他们之间会一直维护一个网络连接，主库会通过这个连接将后续收到的命令操作在同步给从库
- 主从库间网络断了怎么办？
  - 当主从库断连后，主库会把断连期收到的写操作命令，写入replication buffer，同时也会把这些操作命令写入repl_backlog_buffer缓冲区（主库会记录自己写到的位置master_repl_offset，从库则会记录自己已经读到的位置slave_repl_offset）
    - 如果从库的读取速度比较慢，就有可能导致从库还未读取的操作被主库新写的操作覆盖了(环形缓冲区写满后，主库会继续写入），这会导致主从库间的数据不一致。需要调整repl_backlog_size(缓冲空间大小 = 主库写入命令速度 * 操作大小 - 主从库间 网络传输命令速度 * 操作大小)，通常是缓冲空间大小的两倍
#### 哨兵模式（sentinel）：主库挂了，如何不间断服务
- 设置哨兵`sentinel monitor <master-name> <ip> <redis-port> <quorum>`
- 哨兵机制，哨兵的作用：监控，选主和通知
  - 监控
    - 主观下线：哨兵发现ping从库得不到回应，就会把从库标记为下线。
    - 客观下线：对于主数据库，采用哨兵集群，超过一定数量的哨兵判断主数据库下线，才会判定主库下线
  - 选主，首先进行筛选，然后通过打分选出来作为主库
    - 筛选：判断是否在线，使用配置项down-after-milliseconds（断连判断），如果发生断连超过10次，说明这个库的网络状况不好，不适合作为新主库
    - 打分（从库优先级，从库复制进度，从库ID号）
      - 优先级最高的从库得分高，可以通过slave-priority配置项，给不同的库设置不同的优先级，比如内存大的实例设置一个高优先级
      - 和旧主库同步程度最接近的从库得分高，从库的slave_repl_offset最接近master_repl_offset，那么它的得分就最高
      - 在优先级和复制进度都相同的情况下，ID号最小的从库得分最高，会被选为新主库
  - 通知
    - 哨兵会把新主库的连接信息发给其他从库，让 它们执行replicaof命令，和新主库建立连接，并进行数据复制。同时，哨兵会把新主库的连接信息通知给客 戶端，让它们把请求操作发到新主库上。
#### 哨兵集群：哨兵挂了，主从库还能切换吗？
- 基于pub/sub机制的哨兵集群组成
  - 只要哨兵和主库建立了联系，就可以在主库上发布消息，也可以从主库上订阅消息，获得其他哨兵发布的连接信息，当多个哨兵实例在主库上做了发布和订阅操作后，他们之间就知道彼此的IP地址和端口
  - 只有订阅了同一个频道的应用才能通过发布的消息进行信息交换
- 基于info命令的从库列表，可以帮助哨兵和从库建立连接
- 基于哨兵自身的pub/sub功能，实现了客户端和哨兵之间的事件通知
- `SUBSCRIBE +odown`订阅所有实例进入客观下线状态的事件 `PSUBSCRIBE *`订阅所有的事件
- 由哪个哨兵执行主从切换：选举出哨兵的leader
  - 拿到半数以上的赞成票
  - 拿到的票数同时还需要大于等于哨兵配置文件中的quorum值
#### 切片集群：数据增多了，是该加内存还是加实例
- 纵向扩展
  - 升级单个Redis实例，增加内存容量，增加磁盘容量，使用更高配置的CPU
- 横向扩展
  - 增加当前Redis实例的个数
    - 数据切片后，在多个实例之间如何分布（Redis Cluster采用哈希槽，一个切片集群共有16384个哈希槽）
      - 键值对对应到哈希槽上：首先根据键值对的key，按照CRC16算法计算出一个16bit的值，然后用这个值对16384取模，这个模数代表一个相应编号的哈希槽
      - 哈希槽对应到Redis实例上：Redis自动分配时按照16384/N（实例个数）来分配。手动分配的时候，需要吧16384个槽都分配完。
    - 客户端怎么确定想要访问的数据在哪个实例上
      - 客户端和集群实例建立连接后，shi