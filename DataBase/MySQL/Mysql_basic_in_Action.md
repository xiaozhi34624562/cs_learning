### Basic

- **SQL查询语句是如何执行的**（Server层，存储引擎层）`mysql> select * from T where ID=10；`
  - Server层
    - 连接器：负责跟客户端建立连接，获取权限，维持和管理连接 `mysql -h $ip -P $port -u $user -p` 一个用户成功建立连接后，即使你用管理员账号权限对这个用户的权限做了修改，也不会影响已经存在的连接，只有再重新建立连接时才会使用新的权限设置;`show processlist` 可以看到此刻的连接情况; `wait_timeout`通常的设置是8h。
      - 长连接和短连接：长连接积累下来，可能会导致内存占用太大，被系统强行杀掉（OOM），从现象看就是MySQL异常重启了。解决方案：定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连；如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 `mysql_reset_connection` 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态
    - 查询缓存：mysql在拿到查询请求后，会先到查询缓存里面看看，之前是否执行了这条语句，之前执行过的语句及其结果可能会以key-value的形式，直接缓存在内存中。弊端是，当表被更新了，所有跟表有关的缓存都会被删掉。mysql提供了按需使用的方式，`query_cache_type`设置成DEMAND，这样对于默认的SQL语句不使用查询缓存，需要的时候可以用SQL_CACHE显式指定`select SQL_CACHE * from T where ID = 10;`
    - 分析器：先会做词法解析，识别出关键字，表名等，然后做语法分析
    - 优化器：在表里有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联的时候，决定各个表的连接顺序，
    - 执行器：分析器决定了要做什么，优化器决定了怎么做。开始执行的时候，会先检测是否有权限（如 select），然后执行。
      - 比如`select * from T where ID=10`ID字段没有索引。
        - 调用InnoDB引擎接口取这个表的第一行，判断id是不是10，如果不是则跳过，如果是则存在结果集中。
        - 盗用引擎接口取下一行，重复相同的判断逻辑，直到取到这个表的最后一行
        - 执行期将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端
  - 存储引擎层
    - InnoDB
    - MyISAM
    - Memory
    - ![截屏2021-05-24 14.40.55](/Users/sxvw/Desktop/截屏2021-05-24 14.40.55.png)

- **sql更新语句是如何执行的**
  - 首先连接器会连接数据库；表上有更新，所以所有的查询缓存消失；分析器会通过词法和语法解析知道这是更新语句；优化器决定使用ID这个索引，然后执行器负责具体执行。
  - 当一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里面，并更新内存。同时，InnoDB会在适当的时候，将这个操作记录更新到磁盘里，这个更新往往是在系统比较空闲的时候做。
  - **redo log（重做日志）**：Innodb的redo log的大小是固定的，比如可以配置为一组4个文件，每个文件大小1GB，那么总共就可以记录4GB的操作，写到末尾又回到开头循环写
    - write pos是当前记录的位置，一边写一边后移；checkpoint是当前要擦除的位置，擦出前要把记录更新到数据文件。两者之间空着的空间，可以哦你过来记录新的操作。
    - 有了redo log，可以保证及时数据库发生异常重启，之前提交的记录都不会丢，crash-safe。
    - redo log的三种状态：
      - 存在redo log buffer中，物理上是在mysql进程内存中
      - 写到磁盘（write），但是没有持久化（fsync），物理上是在文件系统的page cache（是操作系统的文件系统上的，属于操作系统的内存）里面
      - 持久化到磁盘，对应的是hard disk
    - redo log写入的策略`innodb_flush_log_at_trx_commit`， 有三种
      - 0，表示每次事务提交时都只是把 redo log 留在 redo log buffer 中
      - 1 ，表示每次事务提交时都将 redo log 直接持久化到磁盘
      - 2，表示每次事务提交时都只是把 redo log 写到 page cache
  - **binlog（归档日志）**：
    - binlog是在事物最终提交前写入。事务在执行过程中，先把日志写到binlog cache，事务提交的时候，再把binlog cache写到binlog文件中
    - 写入的三种策`sync_binlog`略：
      - 0，表示每次提交事务都只 write ，不 fsync 
      - 1，表示每次提交事务都会执行 fsync 
      - N（N>1），表示每次提交事务都 write ，但累积 N 个事务后才 fsync 
  - 对比
    - server层，主要是mysql功能层面的事情，所有引擎都可以使用，用binlog；引擎层Innodb，负责存储相关的具体事宜，用redo log
    - redo log是物理日志，记录的是在某个数据页上做了什么修改；binlog是逻辑日志，记录的是这个语句的愿是逻辑，比如给ID=2这一行的a字段加1
    - redo log是循环写的，空间固定会用完；binlog是可以追加写入的，在binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志
  - 执行过程
    - 执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回
    - 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据
    - 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。
    - 执行器生成这个操作的 binlog，并把 binlog 写入磁盘
    - 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。