## 悲观锁和乐观锁

- 悲观锁: 认为自己在使用数据的时候, 一定会有别的线程来修改数据, 因此在获取数据的时候会先加锁. java中, synchronized和Lock的实现类都是悲观锁. **适合写操作多**的场景, 先加锁可以保证写操作时数据正确.
- 乐观锁: 读取数据的时候不会添加锁, 只是在更新数据的时候去判断之前有没有别的线程更新了这个数据. **适合读操作多**的场景, 不加锁的特点能够使其读操作的性能大幅提高. Java中通过CAS算法实现
  - CAS(Compare and Swap)算法: 需要读写的内存值V, 进行比较的值A, 要写入的新值B. 当且仅当V的值等于A时, CAS通过原子方式用新值B来更新V的值, 一般情况下, 更新是一个不断重试的操作. JDK中通过CPU的cmpxchg指令, 去比较寄存器中的A和内存中的值V, 如果想等, 就要把写入的新值B存入内存中. 如果不想等, 就将内存值V赋值给寄存器中的值A, 然后通过java代码中的while循环再次调用cmpxchg指令进行重试, 直到设置成功.
  - CAS存在的问题:
    - ABA问题: 如果内存值原来是A, 后来变成了B, 然后又变成了A, 那么CAS进行检查的时候发现值没有发生变化, 但实际上发生了变化.  通过变量前面添加版本号. 在AtomicStampedReference中解决了这个问题.
    - 循环时间长开销大. CAS操作如果长时间不成功, 会导致其一直自旋, 给CPU带来非常的的开销.
    - 只能保证一个共享变量的原子操作. 从jdk 1.5开始, 通过AtomicReference类保证引用对象之间的原子性, 把多个变量封装在一个对象中.

## 自旋锁和适应性自旋锁

阻塞或者唤醒一个Java线程, 需要操作系统切换CPU状态来完成, 这种切换需要耗费处理器时间, 如果同步代码块过于简单, 状态转化消耗的时间有可能比用户代码执行的时间还要长.

- 自旋锁: 让当前线程进行自旋, 如果在自旋完成后, 前面锁定同步资源的线程已经释放了锁, 那么当前线程就可以不必阻塞而是直接获得同步资源, 从而避免切换线程的开销, 这就是自旋锁. 自旋锁的原理同样也是CAS, AtomicInteger中调用Unsafe进行自增操作getAndAddInt()中的do-while循环就是一个自旋操作, 如果修改数值失败, 则通过循环来执行自旋, 直到修改成功. 
- 自旋锁的缺点: 自旋等待虽然避免了线程切换的开销, 但它要占用处理器时间. 自旋等待的时间必须要有一定的限度, 默认是10次. 
- 自适应性自旋锁: 自旋的时间(次数)不再固定, 而是由前一次在同一个锁上的自旋时间及锁拥有者的状态类决定的.对于某个锁, 如果自旋很少成功, 那以后再尝试后的这个锁的时候, 可能直接阻塞线程

## Synchronized的锁: 无锁, 偏向锁, 轻量锁, 重量锁

#### Java对象头(Mark Word, Klass Pointer)

- Mark Word: 默认储存的是对象的HashCode, 分代年龄和锁标志位信息. 这些信息都是与对象自身定义无关的数据, 所以MW被设计成一个非固定的数据结构, 以便在很小的空间内存储尽量多的数据. 在运行期间MW里存储的数据会随着锁标志位的变化而变化.
- Klass Pointer:  对象指向它的类元数据的指针, 虚拟机根据这个指针来判断这个对象是哪个类的实例
- Monitor: 一种同步机制, 每个java对象就有一把看不见的锁, 成为内部锁或者Monitor锁. Monitor是线程私有的数据结构, 每个线程都有一个可用monitor record列表, 同时还有一个全局可用的列表. 每个被锁住的对象都会和一个monitor关联, 同时Monitor里面有一个Owner字段, 用来存放拥有该锁的线程的唯一标识, 表示该锁被这个线程占用. 

synchronized通过Monitor来实现线程同步, Monitor是依赖于底层的操作系统的Mutex Lock来实现的线程同步.

|  锁状态  |                       存储内容                        | 锁标志位 |
| :------: | :---------------------------------------------------: | :------: |
|   无锁   |     对象的hashCode, 对象分代年龄, 是否是偏向锁(0)     |    01    |
|  偏向锁  | 偏向线程ID, 偏向时间戳, 对象分代年龄, 是否是偏向锁(1) |    01    |
| 轻量级锁 |                 指向栈中锁记录的指针                  |    00    |
| 重量级锁 |              指向互斥锁(重量级锁)的指针               |    10    |

- **无锁**: 修改操作在循环中进行, 线程会不断的尝试修改共享资源. 如果没有冲突, 就修改成功并退出, 否则就继续循环尝试. CAS原理及应用就是无锁的实现.
- **偏向锁:** 一段同步代码一直被一个线程所访问, 那么该线程会自动获取锁, 降低获取锁的代价. 当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。
  - 偏向锁变化: 只有遇到其他线程尝试竞争偏向锁时, 持有偏向锁的线程才会释放锁, 线程不会主动释放锁. 偏向锁的撤销, 需要等待全局安全点(在这个时间点上, 没有字节码正在执行), 它会首先暂停拥有偏向锁的线程, 判断锁对象是否处于被锁定状态. 撤销偏向锁后恢复到无锁或轻量锁的状态. 
- **轻量级锁:** 当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。
  - 轻量级锁的实现过程: 
    - 在代码进入同步块的时候, 如果同步对象锁状态为无锁状态, 虚拟机首先将在当前线程的栈帧中建立一个名为锁记录(Lock Record)的空间, 用于存储锁对象目前的Mark Word的拷贝, 然后拷贝对象头中的Mark Word复制到锁记录中 
    - 拷贝成功后, 虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针, 并将Lock Record里的Owner指针指向对象的Mark Word
    - 如果这个更新成功之后, 这个线程就有了该对象的锁吗并且对象Mark Word的锁标志位设置成“00”. 
    - 如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。
- **重量级锁:**升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。

## 公平锁和非公平锁

## 可重入锁和非可重入锁
## 共享锁和排他锁

AtomicInteger getAndAddInt()循环获取给定对象o中的偏移量处的值v，然后判断内存值是否等于???????????????

轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。