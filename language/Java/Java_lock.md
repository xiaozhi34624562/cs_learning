# Java中的常见锁

## 悲观锁和乐观锁

- 悲观锁: 认为自己在使用数据的时候, 一定会有别的线程来修改数据, 因此在获取数据的时候会先加锁. java中, synchronized和Lock的实现类都是悲观锁. **适合写操作多**的场景, 先加锁可以保证写操作时数据正确.
- 乐观锁: 读取数据的时候不会添加锁, 只是在更新数据的时候去判断之前有没有别的线程更新了这个数据. **适合读操作多**的场景, 不加锁的特点能够使其读操作的性能大幅提高. Java中通过CAS算法实现
  - CAS(Compare and Swap)算法: 需要读写的内存值V, 进行比较的值A, 要写入的新值B. 当且仅当V的值等于A时, CAS通过原子方式用新值B来更新V的值, 一般情况下, 更新是一个不断重试的操作. JDK中通过CPU的cmpxchg指令, 去比较寄存器中的A和内存中的值V, 如果想等, 就要把写入的新值B存入内存中. 如果不想等, 就将内存值V赋值给寄存器中的值A, 然后通过java代码中的while循环再次调用cmpxchg指令进行重试, 直到设置成功.
  - CAS存在的问题:
    - ABA问题: 如果内存值原来是A, 后来变成了B, 然后又变成了A, 那么CAS进行检查的时候发现值没有发生变化, 但实际上发生了变化.  通过变量前面添加版本号. 在AtomicStampedReference中解决了这个问题.
    - 循环时间长开销大. CAS操作如果长时间不成功, 会导致其一直自旋, 给CPU带来非常的的开销.
    - 只能保证一个共享变量的原子操作. 从jdk 1.5开始, 通过AtomicReference类保证引用对象之间的原子性, 把多个变量封装在一个对象中.

## 自旋锁和适应性自旋锁

阻塞或者唤醒一个Java线程, 需要操作系统切换CPU状态来完成, 这种切换需要耗费处理器时间, 如果同步代码块过于简单, 状态转化消耗的时间有可能比用户代码执行的时间还要长.

- 自旋锁: 让当前线程进行自旋, 如果在自旋完成后, 前面锁定同步资源的线程已经释放了锁, 那么当前线程就可以不必阻塞而是直接获得同步资源, 从而避免切换线程的开销, 这就是自旋锁. 自旋锁的原理同样也是CAS, AtomicInteger中调用Unsafe进行自增操作getAndAddInt()中的do-while循环就是一个自旋操作, 如果修改数值失败, 则通过循环来执行自旋, 直到修改成功. 
- 自旋锁的缺点: 自旋等待虽然避免了线程切换的开销, 但它要占用处理器时间. 自旋等待的时间必须要有一定的限度, 默认是10次. 
- 自适应性自旋锁: 自旋的时间(次数)不再固定, 而是由前一次在同一个锁上的自旋时间及锁拥有者的状态类决定的.对于某个锁, 如果自旋很少成功, 那以后再尝试后的这个锁的时候, 可能直接阻塞线程

## Synchronized的锁: 无锁, 偏向锁, 轻量锁, 重量锁

#### Java对象头(Mark Word, Klass Pointer)

- Mark Word: 默认储存的是对象的HashCode, 分代年龄和锁标志位信息. 这些信息都是与对象自身定义无关的数据, 所以MW被设计成一个非固定的数据结构, 以便在很小的空间内存储尽量多的数据. 在运行期间MW里存储的数据会随着锁标志位的变化而变化.
- Klass Pointer:  对象指向它的类元数据的指针, 虚拟机根据这个指针来判断这个对象是哪个类的实例
- Monitor: 一种同步机制, 每个java对象就有一把看不见的锁, 成为内部锁或者Monitor锁. Monitor是线程私有的数据结构, 每个线程都有一个可用monitor record列表, 同时还有一个全局可用的列表. 每个被锁住的对象都会和一个monitor关联, 同时Monitor里面有一个Owner字段, 用来存放拥有该锁的线程的唯一标识, 表示该锁被这个线程占用. 

synchronized通过Monitor来实现线程同步, Monitor是依赖于底层的操作系统的Mutex Lock来实现的线程同步.

|  锁状态  |                       存储内容                        | 锁标志位 |
| :------: | :---------------------------------------------------: | :------: |
|   无锁   |     对象的hashCode, 对象分代年龄, 是否是偏向锁(0)     |    01    |
|  偏向锁  | 偏向线程ID, 偏向时间戳, 对象分代年龄, 是否是偏向锁(1) |    01    |
| 轻量级锁 |                 指向栈中锁记录的指针                  |    00    |
| 重量级锁 |              指向互斥锁(重量级锁)的指针               |    10    |

- **无锁**: 修改操作在循环中进行, 线程会不断的尝试修改共享资源. 如果没有冲突, 就修改成功并退出, 否则就继续循环尝试. CAS原理及应用就是无锁的实现.
- **偏向锁:** 一段同步代码一直被一个线程所访问, 那么该线程会自动获取锁, 降低获取锁的代价. 当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。
  - 偏向锁变化: 只有遇到其他线程尝试竞争偏向锁时, 持有偏向锁的线程才会释放锁, 线程不会主动释放锁. 偏向锁的撤销, 需要等待全局安全点(在这个时间点上, 没有字节码正在执行), 它会首先暂停拥有偏向锁的线程, 判断锁对象是否处于被锁定状态. 撤销偏向锁后恢复到无锁或轻量锁的状态. 
- **轻量级锁:** 当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。
  - 轻量级锁的实现过程: 
    - 在代码进入同步块的时候, 如果同步对象锁状态为无锁状态, 虚拟机首先将在当前线程的栈帧中建立一个名为锁记录(Lock Record)的空间, 用于存储锁对象目前的Mark Word的拷贝, 然后拷贝对象头中的Mark Word复制到锁记录中 
    - 拷贝成功后, 虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针, 并将Lock Record里的Owner指针指向对象的Mark Word
    - 如果这个更新成功之后, 这个线程就有了该对象的锁吗并且对象Mark Word的锁标志位设置成“00”. 
    - 如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。
- **重量级锁:**升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。

轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。<br></br>

综上, 偏向锁通过对比Mark Word解决加锁问题, 避免执行CAS操作; 而轻量级锁是通过用CAS操作和自旋来解决加锁问题, 避免线程阻塞和唤醒而影响性能; 重量级锁是将除了拥有锁的线程以外的线程都阻塞. 

## 公平锁和非公平锁

- **公平锁**: 多个线程按照申请锁的顺序来获取锁, 线程直接进入队列中排队, 排队中的第一个线程才能获得锁
  - 优点: 等待锁的线程不会饿死
  - 缺点: 整体吞吐效率相对非公平锁要低, 等待队列中除第一个线程以外的所有线程都会阻塞, CPU唤醒阻塞线程的开销比非公平锁大.
- **非公平锁**: 多个线程加锁时直接尝试获取锁, 获取不到才会到等待队列的队尾等待. 
  - 优点: 可以减少唤起线程的开销, 整体吞吐效率高, 因为线程有几率不阻塞直接获得锁, CPU不必唤醒所有线程. 
  - 缺点: 处于等待队列中的线程可能会饿死, 或者等待很久才会获得锁. 
- **ReentrantLock:** 在这个类里面有一个内部类Sync, 有公平锁FairSync和非公平锁NonfairSync两个子类. ReentrantLock默认使用非公平锁, 也可以通过构造器来显示的指定使用公平锁. 
  - 公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasQueuedPredecessors() 主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。

## 可重入锁和非可重入锁

- **可重入锁(递归锁)**: 在同一个线程在外层方法获取锁的时候, 在进入该线程的内存方法会自动获取锁(前提是锁对象得是同一个对象或者class), 不会因为之前获得过还没释放而阻塞. ReentrantLock和synchronized都是可重入锁, 在一定程度上可以避免死锁. 

- **非可重入锁: **当前线程在调用方法内的方法时, 需要将执行当前方法获取的对象的锁匙放掉, 实际上该对象锁已经被当前线程所持有, 且无法释放, 所以此时会死锁. 

- **ReentrantLock和NonReentrantLock的对比分析:**

  - 首先ReentrantLock和NonReentrantLock都继承父类AQS，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0。

  - 当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status == 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。

  - 释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。

    <img src="/Users/sxvw/Desktop/截屏2021-06-18 10.45.04.png" alt="截屏2021-06-18 10.45.04" style="zoom:100%;" />

## 共享锁和独享锁

- **独享锁**:  该锁一次只能被一个线程所持有, 如果线程T对数据A加上排它锁后, 则其他线程不能再对A加任何类型的锁. 获得排他锁的线程既能读数据又能修改数据.
- **共享锁:** 锁可以被多个线程所持有, 如果线程T对数据A加上共享锁后, 则其他线程只能对A再加共享锁, 不能加排他锁. 获得共享锁的线程只能读数据, 不能修改数据. 
- ReentrantReadWriteLock: 里面有ReadLock(共享锁)和WriteLock(独享锁). 读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。
  - AQS的state字段(int类型, 32位), 用来描述有多少线程获持有锁. 在独享锁中这个值通常是0或者1(如果是重入锁的话state值就是重入的次数), 在共享锁中state就是持有锁的数量.
  - 在ReentrantReadWriteLock中有读写两把锁, 高16位表示读锁个数, 低16位表示写锁状态
  - WriteLock()
    - 这段代码首先取到当前锁的个数c，然后再通过c来获取写锁的个数w。因为写锁是低16位，所以取低16位的最大值与当前的c做与运算（ int w = exclusiveCount©; ），高16位和0与运算后是0，剩下的就是低位运算的值，同时也是持有写锁的线程数目。
    - 在取到写锁线程的数目后，首先判断是否已经有线程持有了锁。如果已经有线程持有了锁(c!=0)，则查看当前写锁线程的数目，如果写线程数为0（即此时存在读锁）或者持有锁的线程不是当前线程就返回失败（涉及到公平锁和非公平锁的实现）。
    - 如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。
    - 如果当且写线程数为0（那么读线程也应该为0，因为上面已经处理c!=0的情况），并且当前线程需要阻塞那么就返回失败；如果通过CAS增加写线程数失败也返回失败。
    - 如果c=0,w=0或者c>0,w>0（重入），则设置当前线程或锁的拥有者，返回成功！
  - ReadLock()
    - 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是“1<<16”

# 从ReentrantLock来看AQS的原理及应用

- ReentrantLock和Synchronized的比较

|            |         ReentrantLock          |   Synchronized   |
| :--------- | :----------------------------: | :--------------: |
| 锁实现机制 |            依赖AQS             |    监视器模型    |
| 灵活性     | 支持响应中断、超时、尝试获取锁 |      不灵活      |
| 释放形式   |       必须显示调用释放锁       |  自动释放监视器  |
| 锁类型     |        非公平锁和公平锁        |     非公平锁     |
| 条件队列   |       可关联多个条件队列       | 关联一个条件队列 |
| 可重入性   |             可重入             |      可重入      |

## AQS

- **原理概览**: 如果被请求的共享资源空闲, 那么就将当前请求资源的线程设置为有效的工作线程, 将共享资源设置为锁状态; 如果共享资源被占用, 就需要一定的阻塞等待唤醒机制来保证锁分配. 这个机制主要用的是CLH队列的变体实现的, 将暂时获取不到锁的线程加入到队列中
  - CHL(Craig, Landin and Hagersten): 是单向链表, AQS中的队列是CLH变体的虚拟双向队列(FIFO), AQS是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配. 
  - AQS使用一个Volatile的int类型的成员变量来表示同步状态, 通过内置的FIFO队列来完成资源获取的排队工作, 通过CAS完成对State值的修改. 
- **数据结构**:Node, Node是CLH变体队列中的节点
  - 典型方法和属性的含义

| 方法和属性  | 含义                              |
| ----------- | --------------------------------- |
| waitStatus  | 当前节点在队列中的状态            |
| thread      | 表示处于该节点的线程              |
| prev        | 前驱指针                          |
| predecessor | 返回前驱节点, 没有的话抛出npe     |
| nextWaiter  | 指向下一个处于condition状态的节点 |
| next        | 后继指针                          |

- 数据结构
  - 线程两种锁的模式:
    - `SHARED`: 表示线程以共享的模式等待锁
    - `EXCLUSIVE:` 表示线程正在以独占的方式等待锁
  - `waitStatus`: 有下面几个枚举值
    - `0`: 当一个Node被初始化的时候的默认值
    - `CANCELLED`:  为1, 表示线程获取锁的请求已经取消了
    - `CONDITION`:  为-2, 表示节点在等待队列中, 节点线程等待唤醒
    - `PROPAGATE`:  为-3, 当前线程处在SHARED情况下, 该字段才会用
    - `SIGNAL`:  为-1, 表示线程已经准备好了, 就等资源释放了

- **同步状态State**: AQS中维护了一个名为state的字段, 由Volatile修饰, 用来展示当前临界资源的获锁情况. AQS里面通过几个final修饰的方法来修改state
  - `protected final int getState():` 获取State的值
  - `protected final void setState():`  设置State的值
  - `protected final boolean compareAndSetState(int expect, int update):` 使用CAS方式更新State
- AQS重要方法与ReentrantLock的关联
  - `protected boolean isHeldExclusively()`: 该线程是否正在独占资源。只有用到Condition才需要去实现它。
  - `protected boolean tryAcquire(int arg)`: 独占方式。arg为获取锁的次数，尝试获取资源，成功则返回True，失败则返回False。
  - `protected boolean tryRelease(int arg)`: 独占方式。arg为释放锁的次数，尝试释放资源，成功则返回True，失败则返回False。
  - `protected int tryAcquireShared(int arg)`: 共享方式。arg为获取锁的次数，尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。
- **加锁:** 
  -  通过ReentrantLock的加锁方法Lock进行加锁操作
  - 会调用到内部类Sync的Lock方法, 由于Sync的Lock是抽象方法, 根据ReentrantLock的初始化选择的fair和unfair来执行相关的Lock方法, 本质上都会执行AQS的Acquire方法
  - AQS的Acquire方法会执行tryAcquire方法, 但是由于tryAcquire需要自定义同步器实现, 因此执行了ReentrantLock中的tryAcquire方法, 由于ReentrantLock是通过公平锁和非公平锁内部类实现的tryAcquire方法, 因此会根据锁类型不同, 执行不同的tryAcquire.
  - tryAcquire是获取逻辑锁, 获取失败后, 会执行框架AQS的后续逻辑, 跟ReentrantLock自定义同步器无关. 
- **解锁:** 
  - 通过ReentrantLock的解锁方法Unlock进行解锁
  - Unlock会调用内部类Sync的Release方法, 该方法继承于AQS
  - Release中会调用tryRelease方法, tryRelease需要自定义同步器实现, tryRelease只在ReentrantLock中的Sync实现，因此可以看出，释放锁的过程，并不区分是否为公平锁.
  - 释放成功后，所有处理由AQS框架完成，与自定义同步器无关

## 通过ReentrantLock理解AQS

- 线程加入等待队列
  - 加入队列的时机: 当执行Acquire(1)时, 会通过tryAcquire获取锁. 如果获取锁失败, 就会调用addWaiter加入到等待队列中去.
  - 如何加入队列: 获取锁失败后, 会执行addWaiter(Node.EXCLUSIVE)加入等待队列.
    - 通过当前线程和锁模式建一个新节点
    - Pred指向尾节点tail
    - 将新节点中的prev指针指向Pred
    - 通过compareAndSetTail方法, 完成尾节点的设置. 这个方法主要是对tailOffset和Expect进行比较, 如果tailOffset的Node和Expect的Node地址相同, 那么设置Tail的值为Update的值
    - 如果Pred指针是Null（说明等待队列中没有元素），或者当前Pred指针和Tail指向的位置不同（说明被别的线程已经修改）, 就要执行enq方法
      - 如果没有被初始化, 需要进行初始化一个头节点出来. 初始化的头节点并不是当前线程节点, 而是调用了午餐构造函数的节点. 如果经历了初始化或者并发导致队列中有元素, 则与之前的方法相同. 
  - 公平锁使用的hasQueuedPredecessors方法中的`h != t && ((s = h.next) == null || s.thread != Thread.currentThread())`
    - 双向列表中, 第一个节点为虚节点, 并不储存任何信息, 只是占位. 真正的第一个有数据的节点, 是在第二个节点开始的. 
    - 当h!=t时, 如果(s = h.next) == null, 等待队列正在有线程进行初始化, 但只是进行到了Tail指向Head, 还没有将Head指向Tail, 此时队列中有元素, 需要返回True. 
    - 如果(s = h.next) != null, 说明此时队列中至少有一个有效节点. 如果此时s.thread == Thread.currentThread(), 说明等待队列的第一个有效节点中的线程和当前线程相同, 那么当前线程时可以获取资源的;
    - 如果s.thread != Thread.currentThread()，说明等待队列的第一个有效节点线程与当前线程不同，当前线程必须加入进等待队列
    - 节点入队不是院子操作, 所以会短暂出现head != tail, 此时Tail指向最后一个节点, 而且Tail指向Head. 如果Head没有指向Tail, 这种情况下也需要将相关线程加入队列中. 所以这块代码是为了解决极端情况下的并发问题
- 等待队列中线程出队列时机(acquireQueued)
  - 靠前驱节点判断当前节点是否需要阻塞 `shouldParkAfterFailedAcquire`
  - `parkAndCheckInterrupt`主要用于挂起当前线程，阻塞调用栈，返回当前线程的中断状态
- CANCELLED状态节点生成
  - 获取当前节点的前驱节点，如果前驱节点的状态是CANCELLED，那就一直往前遍历，找到第一个waitStatus <= 0的节点，将找到的Pred节点和当前Node关联，将当前Node设置为CANCELLED
  - 根据当前节点的位置，考虑以下三种情况：
    - 当前节点是尾节点: 将从后往前的第一个非取消状态的节点设置成尾节点, 如果更新成功, 将tail的后继节点设置为null
    - 当前节点是Head的后继节点: 唤醒当前节点的后继节点
    - 当前节点不是Head的后继节点，也不是尾节点: 判断当前节点的前驱节点是否为SIGNAL, 如果不是, 则把前驱节点设置为SIGNAL看是否能成功.
  - 上述的操作中, 我们所有的变化都是对Next指针, 而没有修改Prev指针的原因:
    - 执行cancalAcquire的时候, 当前节点的前置节点可能已经从队列中出去了, 如果此时修改Prev指针, 有可能会导致Prev指向另一个已经移除队列的Node, 不安全
    - 在shouldParkAfterFailedAcquire方法中, 会执行`node.prev = pred = pred.prev while (pred.waitStatus > 0) `就是在处理prev指针. shouldParkAfterFailedAcquire是在获取锁失败的情况下才会执行, 进去方法后, 说明共享锁已被获取, 当前节点之前的节点都不会变化, 因此这个时候更新prev指针比较安全. 

