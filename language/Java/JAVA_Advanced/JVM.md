## JVM虚拟机论述题
### 题目01 用自己的语言向我介绍Java运行时数据区
- 堆、虚拟机栈、本地方法栈、方法区（永久代、元空间）、运行时常量池（字符串常量池）、直接内存？
  - **堆**：线程间共享的区域，分为年轻代和老年代，占比为1:2。年轻代分为eden区和survive to区和surviv from区，占比为8:1:1. 新产生的对象最早在eden区，第一次gc后，如果存活，会进去survive区。在gc年龄超过15（default）；年轻代放不下；通过内存担保；大对象，该对象会被放入到老年代中。
  - **虚拟机栈**：一个方法的调用，对应着一个栈帧的出栈和入栈。里面包含：局部变量表、操作数栈、方法返回地址和动态连接。有两种异常：线程请求的栈深度超过了虚拟机允许的最大栈深度；没有足够的内存区创建虚拟机栈。
  - **本地方法栈**：Java调用Native方法（C++方法）时，会生成本地方法栈。
  - **方法区**：包含：类信息（Class信息、方法信息、字段信息、类变量和方法表）、运行时常量池和JIT编译的代码。jdk1.8以前，方法区的信息放在永久代里面，永久代放在堆内存里面；jdk1.8以后，方法区的信息放在元空间里面，其中静态变量和运行时常量池是放在堆里面，此时的元空间的大小只受限于机器的物理内存。原因：字符串在永久代中，容易导致永久代内存溢出；类信息的大小不好确定，所以不好在永久代里给出合适的内存大小；永久代导致内存回收时分代太多，过于复杂；Orcal将hotspot和jRockit合并了。
  - **运行时常量池**：字符串常量池使用hash方法进行存储，全局唯一
  - **直接内存**：独立于虚拟机外的内存，只受本机内存大小的限制。直接内存再申请内存空间时相比较在堆内申请内存要慢，但是IO读写的性能比堆内内存要快。适用的场景：有很大的内存需要存储；频繁IO。
- 为什么要分年轻代和老年代？
  - 大部分对象都是朝生夕灭的，而存活下来的对象会存活很久，所以在堆内的对象可以分代处理。对于年轻代，在gc的时候采取标记-复制，因为只有小部分的对象会留下来，所以复制会很快，因为留下来的很少，所以复制时留的冗余空间也不用很多；对于老年代，在gc的时候采用标记-整理获知标记-清楚，因为只有很少的对象需要处理。
  
### 题目02 描述一个Java对象的生命周期
- 解释一个对象的创建过程
  - new一个对象的时候，首先会在常量池中中检查是否有这个class对象，如果没有的话，首先实行类加载操作，之后开始分配内存空间，在内存空间赋予初始值，之后设置必要的信息（hash，gc年龄，klass pointer等），最后执行init方法。
- 解释一个对象的内存分配
  - 有两种分配方法：指针碰撞，分配连续的内存，速度快，适用于年轻代；空闲指针，零散的内存，适用于老年代。但这两种方法都会遇到并发时的安全问题，解决方法是：CAS加失败重试或者Thread local allocation buffer为每个线程预先分配内存。JVM在第一次给线程分配对象的时候，采用CAS进行TLAB的分配，当分配的空间适用完时，采用CAS进行内存分配。
- 解释一个对象的销毁过程
  - 可达性分析，第一次不可达时会被标记，此时会查看是否有finilize方法，且方法没有被执行过。之后进行第二次标记，之后就会被回收。
- 对象的两种访问方式是什么
  - 句柄访问：有一个表，对象指向这个表中的一项，这一项的值指向真实的内存地址。优点是，内存地址改变时，只需要修改句柄表就可以，缺点是多了一次查找
  - 直接访问，直接指向内存位置
- 为什么需要内存担保
  - 年轻代的空间不够时，对象会尝试存储在老年代，前提是老年代有足够的空间，如果没有的话，进行三次full gc，如果还是没有空间，就OOM了。
  
### 题目03 垃圾回收算法有哪些？垃圾收集器有哪些？他们的特点是什么？
- 垃圾回收算法：
  - 标记-清除，会导致内存破碎，消耗时间随对象增长；标记-整理，涉及到压缩，比较慢；标记-复制，需要额外的空间。
- ParNew收集器
  - Serial收集器的多线程版本。
- ParallelScavenge 收集器
  - 达到一个可控的吞吐量
  - STW对新生代采取标记复制算法
- ParallelOld 收集器
  - parallel scavenge的老年代版本，STW适用多线程进行标记-整理，注重吞吐量，适用于CPU敏感场合
- CMS 收集器
  - gc root进行标记时会STW，接着gc线程和用户线程进行并发标记，然后STW，gc线程来标记并发时产生的垃圾，最后并发清楚垃圾。平时时标记-清楚来处理垃圾，当内存破碎到一定程度时，会标记-整理清楚垃圾，所以有时候会遇到来不及产生足够的内存空尽给新对象。
  - 低延迟，对CPU资源敏感
- G1 收集器
  - 基于region来进行内存分配
  - 采用标记-整理来处理垃圾，局部使用标记-复制
  - 初始标记需要STW，接着和用户线程进行并发标记，然后最终标记需要STW，最终通过设定的最大gc停顿时间和垃圾收集性价比列表来选择合适的收集region，并发清楚垃圾。
  - 每一个region中都有一个转发列表，所以使用的额外内存比较多，适用于大内存的机器。