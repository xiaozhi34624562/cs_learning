## 为什么很多编程语言中数组都从0开始编号
- 线性表：数组，链表，队列，栈等
- 非线性表：二叉树，堆，图
- 数组
  - 线性表结构，用一组连续的内存空间，来存储一组具有相同类型的数据
  - a[i]_address = base_address + i * data_type_size 数组支持访问随机，根据随机访问的时间复杂度为O(1)
  - 插入
    - 由于数组是在连续的空间上，所以当i插入数值时，后面的所有数都要向后移动一位
    - solution：将第i位数字搬到数组元素的最后，把新的元素放在第i个位置
  - 删除
    - 每次删除时，后面的元素向前移动一位。可以将多次删除操作集中在一起执行，提高删除效率
  - 数组的优势：ArrayList无法存储基本数据类型int和long，只能autoboxing成Integer和Long，这样损耗性能。
  - 从0开始是因为下标表示的是偏移量
<br>

## 链表：如何实现LRU缓存淘汰算法
- 链表
  - 通过“指针”将零散的内存块串联起来使用
  - 单链表：头节点用来记录链表的基地址，尾节点指向NULL。插入删除很快，随机访问为O(n)
  - 双向链表: 每个节点有前驱指针和后驱指针
  - 删除操作：
    - 删除结点中“值等于某个给定值”的结点（两种都一样，主要时间在遍历）；
    - 删除给定指针指向的结点
      - 单链表：找到删除的节点，需要遍历知道前驱节点
      - 双向链表：当前节点保留了前驱节点的信息
  - 循环链表：尾节点指向头节点
  - 链表和数组的比较
    - 数组是连续的可以借助CPU的缓存机制，预读数组中的数据，访问效率高；链表在内存中，不是连续的，没有有效预读
    - 数组的大小是固定的，没有足够的连续空间时，显示内存不足，扩容时需要拷贝，费时；链表大小没有限制，可以动态扩容
    - 链表占用的内存更多，频繁的插入删除会导致内存申请和释放，容易造成内存碎片
  - LRU使用单链表实现
    - 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部
    - 如果此数据没有在缓存链表中，又可以分为两种情况：
      - 如果此时缓存未满，则将此结点直接插入到链表的头部
      - 如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部
- 单链表实现回文数
- 单链表反转
- 链表中环的检测
- 两个有序的链表合并
- 删除链表倒数第n个节点
- 求链表的中间节点
<br> 